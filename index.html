<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen"/>
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen"/>
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print"/>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Workshop Domain Driven Design Xebia france</title>
    <meta name="Description" CONTENT="Exercise on Domain Driven Design">
</head>

<body>
<div id="container">
<div class="inner">

<header>
    <h1>Workshop Domain Driven Design</h1>

    <h2>By Xebia France</h2>
</header>

<section id="main_content">
<h3>Domain Driven Design Credit</h3>

<p>Le but de l’exercice est d’analyser le code et les règles fonctionnelles afin d’introduire les notions métiers dans le code à l’aide des concepts issues du DDD.</p>

<p>L’application est un back end dans lequel des utilisateurs peuvent valoriser des emprunts.</p>

<p>
    <ul>
        Un utilisateur a un rôle :
        <li> un vendeur (sales) </li>
        <li> un ingénieur financier (pricer)</li>
        <li> un trader</li>
    </ul>
</p>

<p>
    <ul>
        Dans notre domaine, ces utilisateurs possèdent les informations suivantes :
        <li> name : firstname + lastname du user</li>
        <li> email</li>
    </ul>
</p>

<p>
    <ul>
        Un emprunt possède les caractéristiques suivantes :
        <li> il est identifié par le code de référence qui est unique </li>
        <li> il possède des échéances</li>
        <li> il possède des devises (currencies)</li>
    </ul>
</p>

<p>
    <ul>
        Une échéance correspond à des remboursements périodiques:
        <li> une date de remboursement </li>
        <li> un capital restant dû (crd) : c’est le capital total qui reste après paiement de l’échéance</li>
    </ul>
</p>

<p>
Une devise (EUR, USD, CHF, etc) correspond à la monnaie d’un pays. Cela sert notamment à savoir le taux de conversion d’une devise à l’autre. 
Dans les devises, nous avons la notion de funding : ce sont des devises pour lesquelles nous n’avons pas à effectuer de conversion. 
Le projet contient deux fundings : EUR et USD.
La devise de référence est EUR.
</p>

<p>
    <ul>
        L’application est en relation avec deux autres applications pour:
        <li> récupérer les taux de changes (conversions en devises)</li>
        <li> récupérer les utilisateurs</li>
    </ul>
</p>

<p>Enfin un service est présent permettant d'appliquer le taux de conversion sur les échéances si besoin.</p>

<h3>But de l'exercice</h3>

L'exercice fournit un projet où le domaine est identifié. L'organisation du domaine se base sur l'architecture hexagonale (Port & Adapter).
Le but de l'exercice est de poursuivre le refactoring entamé du domaine.


<p>
    <ul>
        Une entité doit avoir une identité unique. Nous savons qu'un emprunt est identifié par un code de référence. C'est le but de la classe CreditId. Cette dernière possède comme attribut le code de référence et les méthodes equals et hashcode sont basées dessus. Nous devons ajouter cette classe à notre entité Credit :

        <li> Modifier le fichier de configuration Credit.hbm et décommenter le code correspondant </li>
        <li> Ajouter l'attribut CreditId dans la classe Credit </li>
        <li> Ajouter de la validation dans le setter de l'attribut CreditId : ce dernier ne peut pas être null </li>
    <ul>
</p>

<p>
    <ul>
        La classe CreditRepositoryImpl se trouve dans le domaine. Pour respecter les principes de l'architecture hexagonale, cette classe doit se trouver en dehors du domaine. Nous allons également la renommer afin d'avoir un nom plus parlant
        <li> Ajouter un package com.xebia.infrastructure.persistence </li>
        <li> Déplacer la classe CreditRepositoryImpl dans ce package </li>
        <li> Renommer la classe en HibernateCreditRepository </li>
        <li> Modifier également la classe de test correspondante </li>
    <ul>
</p>


----------------------------------------------------------------------------------


<p>
    <ul>
        Faire ressortir les notions métiers :
        <li> Réorganiser les packages du projet </li>
        <li> Distinguer les Entity et Value Object</li>
        <li> Faire ressortir le produit en tant qu’aggrégat
            <ul>
                <li> Ajout d'un identifiant unique => ProductId </li>
                <li> Supprimer les relations bi directionnnelles </li>
            </ul>
        </li>
        <li> Ajouter la notion de FinancialPerson (les utilisateurs de notre domaine) </li>
        <li> Rendre les entités moins anémiques
            <ul>
                <li> Déplacer des méthodes dans les entités </li>
                <li> Intégrer des règles de validations dans les setters </li>
            </ul>
        </li>
        <li> Ajouter de nouveaux objets
            <ul>
                <li> Des builders pour la construction plus lisible </li>
                <li> Utilisez le CreditDecimal pour le crd (EcheanceRequest) </li>
                <li> Rendre des concepts implicites, explicites (String email => EmailAddress object) et des règles de validations </li>
            </ul>
        </li>
        <li> Découpler l’application des autres applications
            <ul>
                <li> mettre en place une couche anti corruption pour DataService </li>
                <li> mettre en place une classe de traduction entre les Users et les FinancialPerson: Sales, Pricer et Trader </li>
            </ul>
        </li>
    </ul>
</p>

</div>
</div>
</body>
</html>
