<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html" xmlns="http://www.w3.org/1999/html">
<head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen"/>
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen"/>
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print"/>
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Workshop Domain Driven Design Xebia france</title>
    <meta name="Description" CONTENT="Exercise on Domain Driven Design">
</head>

<body>
<div id="container">
<div class="inner">

<header>
    <h1>Workshop Domain Driven Design</h1>

    <h2>By Xebia France</h2>
</header>

<section id="main_content">
<h3>Domain Driven Design Credit</h3>

<p>Le but de l’exercice est d’analyser le code et les règles fonctionnelles afin d’introduire les notions métiers dans le code à l’aide des concepts issues du DDD.</p>

<p>L’application est un back end dans lequel des utilisateurs peuvent valoriser des emprunts.</p>

<p>
    <ul>
        Un utilisateur a un rôle :
        <li> un vendeur (sales) </li>
        <li> un ingénieur financier (pricer)</li>
        <li> un trader</li>
    </ul>
</p>

<p>
    <ul>
        Dans notre domaine, ces utilisateurs possèdent les informations suivantes :
        <li> name : firstname + lastname du user</li>
        <li> email</li>
    </ul>
</p>

<p>
    <ul>
        Un emprunt possède les caractéristiques suivantes :
        <li> il est identifié par le code de référence qui est unique </li>
        <li> il possède des échéances</li>
        <li> il possède des devises (currencies)</li>
    </ul>
</p>

<p>
    <ul>
        Une échéance correspond à des remboursements périodiques:
        <li> une date de remboursement </li>
        <li> un capital restant dû (crd) : c’est le capital total qui reste après paiement de l’échéance</li>
    </ul>
</p>

<p>
Une devise (EUR, USD, CHF, etc) correspond à la monnaie d’un pays. Cela sert notamment à savoir le taux de conversion d’une devise à l’autre. 
Dans les devises, nous avons la notion de funding : ce sont des devises pour lesquelles nous n’avons pas à effectuer de conversion. 
Le projet contient deux fundings : EUR et USD.
La devise de référence est EUR.
</p>

<p>
    <ul>
        L’application est en relation avec deux autres applications pour:
        <li> récupérer les taux de changes (conversions en devises)</li>
        <li> récupérer les utilisateurs</li>
    </ul>
</p>

<p>Enfin un service est présent permettant d'appliquer le taux de conversion sur les échéances si besoin.</p>

<h3>But de l'exercice</h3>

<p>
L'exercice fournit un projet où le domaine est identifié. L'organisation du domaine se base sur l'architecture hexagonale (Port & Adapter).
Le but de l'exercice est de poursuivre le refactoring entamé du domaine.
</p>
<p>
Les entités et values object ont été identifié. Pour renforcer cet aspect, notre entité Credit hérite de la classe Entity et les autres classes héritent de IdValueObject.
</p>
<p>
Afin d'appliquer un des principes de l'architecture hexagonale, la configuration d'Hibernate se fait par des fichiers hbm. Cela nous permet de décorréler la technique de notre domaine.
</p>

<h4>1. CreditId</h4>
<p>
    <p>
        Une entité doit avoir une identité unique. Nous savons qu'un emprunt est identifié par un code de référence. C'est le but de la classe CreditId. Cette dernière possède comme attribut le code de référence et les méthodes equals et hashcode sont basées dessus. Nous devons ajouter cette classe à notre entité Credit :
    </p>
    <ul>
        <li> Modifier le fichier de configuration Credit.hbm et décommenter le code correspondant </li>
        <li> Ajouter l'attribut CreditId dans la classe Credit </li>
        <li> Ajouter de la validation dans le setter de l'attribut CreditId : ce dernier ne peut pas être null </li>
    <ul>
</p>

<h4>2. Echeance</h4>
<p>
    <p>
    Nous allons encapsuler les échéances. En effet en terme objet, les échéances doivent être encapsuler dans une notion de book.
    Aussi en DDD, le point d'entrée pour les opérations sur les objets doit passer par l'entité
    </p>
    <ul>
        <li> Créer la classe EcheanceBook avec comme attribut la liste des échéances du la classe Credit </li>
        <li> Modifier le fichier Credit.hbm </li>
        <li> Ajouter la méthode addEcheance à la classe Credit </li>
    <ul>
</p>

<h4>3. HibernateCreditRepository</h4>
<p>
    <p>
        La classe CreditRepositoryImpl se trouve dans le domaine. Pour respecter les principes de l'architecture hexagonale, cette classe doit se trouver en dehors du domaine. Nous allons également la renommer afin d'avoir un nom plus parlant
    </p>
    <ul>
        <li> Ajouter un package com.xebia.infrastructure.persistence </li>
        <li> Déplacer la classe CreditRepositoryImpl dans ce package </li>
        <li> Renommer la classe en HibernateCreditRepository </li>
        <li> Modifier également la classe de test correspondante </li>
    <ul>
</p>

<h4>4. CreditDecimal</h4>
<p>
    <p>
        Nous allons modifier la classe EcheanceRequest et son attribut crd. En effet cet attribut est un BigDecimal : pour effectuer des opérations nous devons tester la nullité et gérer les cas d'exception.<br/>
        C'est dans cet optique que la classe CreditDecimal a été créée. Cette dernière encapsule les traitements (gestion des opérations et arrondis). De plus nous avons également défini cette classe comme un attribut Hibernate.
    </p>
    <ul>
        <li> Modifier la classe EcheanceRequest et utiliser CreditDecimal pour le crd </li>
        <li> Modifier le fichier hbm correspondant </li>
        <li> Modifier les tests </li>
    <ul>
</p>

<h4>5. CreditDataService</h4>
<p>
    <p>
        A cette étape, le code ne compile plus car la classe CreditService applique des taux de change. Cependant notre crd est un CreditDecimal et la classe DataService nous retourne des BigDecimal. Etant donnée que ce service est externe, nous allons ajouter une couche anticorruption.<br/>
        La classe CreditDataService a déjà été ajoutée. Nous remarquons que cette classe se situe dans le package port.adapter.service pour respecter l'architecture hexagonale.
    </p>
    <ul>
        <li> Modifier la classe CreditDataService qui doit avoir comme attribut la classe DataService. Cette classe aura comme méthode getCrossChange et doit retourner un CreditDecimal </li>
        <li> Modifier la classe CreditService </li>
        <li> Modifier les tests </li>
    <ul>
</p>


----------------------------------------------------------------------------------


<p>
    <ul>
        Faire ressortir les notions métiers :
        <li> Réorganiser les packages du projet </li>
        <li> Distinguer les Entity et Value Object</li>
        <li> Faire ressortir le produit en tant qu’aggrégat
            <ul>
                <li> Ajout d'un identifiant unique => ProductId </li>
                <li> Supprimer les relations bi directionnnelles </li>
            </ul>
        </li>
        <li> Ajouter la notion de FinancialPerson (les utilisateurs de notre domaine) </li>
        <li> Rendre les entités moins anémiques
            <ul>
                <li> Déplacer des méthodes dans les entités </li>
                <li> Intégrer des règles de validations dans les setters </li>
            </ul>
        </li>
        <li> Ajouter de nouveaux objets
            <ul>
                <li> Des builders pour la construction plus lisible </li>
                <li> Utilisez le CreditDecimal pour le crd (EcheanceRequest) </li>
                <li> Rendre des concepts implicites, explicites (String email => EmailAddress object) et des règles de validations </li>
            </ul>
        </li>
        <li> Découpler l’application des autres applications
            <ul>
                <li> mettre en place une couche anti corruption pour DataService </li>
                <li> mettre en place une classe de traduction entre les Users et les FinancialPerson: Sales, Pricer et Trader </li>
            </ul>
        </li>
    </ul>
</p>

<footer>

    <h3>Authors and Contributors</h3>

    <p>
        Nicolas Jozwiak (<a href="https://github.com/njozwiak" class="user-mention">@njozwiak</a>),<br/>
        Gérôme Egron (<a href="https://github.com/gegron" class="user-mention">@gegron</a>),<br/>
        Jean-Eudes Couignoux (<a href="https://github.com/jeudes" class="user-mention">@jeudes</a>),<br/>
        Yannick Grenzinger (<a href="https://github.com/ygrenzinger" class="user-mention">@ygrenzinger</a>),<br/> 
    </p>

    Workshop-ddd is maintained by <a href="https://github.com/xebia-france">xebia-france</a><br>

    <p>Le contenu de ce workshop est sous <a
            href="http://creativecommons.org/licenses/by-nc-nd/2.0/fr/">contrat Creative Commons</a>.<br> <br> <a
            href="http://creativecommons.org/licenses/by-nc-nd/2.0/fr/"><img
            src="http://blog.xebia.fr/wp-content/uploads/2012/01/by-nc-nd.png"></a></p>
</footer>

</div>
</div>
</body>
</html>
